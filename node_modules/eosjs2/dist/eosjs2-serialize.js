// copyright defined in eosjs2/LICENSE.txt
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SerialBuffer = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.dateToTimePoint = dateToTimePoint;
exports.timePointToDate = timePointToDate;
exports.dateToTimePointSec = dateToTimePointSec;
exports.timePointSecToDate = timePointSecToDate;
exports.dateToBlockTimestamp = dateToBlockTimestamp;
exports.blockTimestampToDate = blockTimestampToDate;
exports.stringToSymbol = stringToSymbol;
exports.symbolToString = symbolToString;
exports.arrayToHex = arrayToHex;
exports.hexToUint8Array = hexToUint8Array;
exports.createInitialTypes = createInitialTypes;
exports.getType = getType;
exports.getTypesFromAbi = getTypesFromAbi;
exports.transactionHeader = transactionHeader;
exports.serializeActionData = serializeActionData;
exports.serializeAction = serializeAction;

require("text-encoding")
var _eosjs2Numeric = require('./eosjs2-numeric');

var numeric = _interopRequireWildcard(_eosjs2Numeric);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SerialBuffer = exports.SerialBuffer = function () {
    function SerialBuffer() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            textEncoder = _ref.textEncoder,
            textDecoder = _ref.textDecoder;

        _classCallCheck(this, SerialBuffer);

        this.length = 0;
        this.array = new Uint8Array(1024);
        this.readPos = 0;
        this.textEncoder = textEncoder || new TextEncoder();
        this.textDecoder = textDecoder || new TextDecoder('utf-8', { fatal: true });
    }

    _createClass(SerialBuffer, [{
        key: 'reserve',
        value: function reserve(size) {
            if (this.length + size <= this.array.length) return;
            var l = this.array.length;
            while (this.length + size > l) {
                l = Math.ceil(l * 1.5);
            }var newArray = new Uint8Array(l);
            newArray.set(this.array);
            this.array = newArray;
        }
    }, {
        key: 'asUint8Array',
        value: function asUint8Array() {
            return new Uint8Array(this.array.buffer, 0, this.length);
        }
    }, {
        key: 'pushArray',
        value: function pushArray(v) {
            this.reserve(v.length);
            this.array.set(v, this.length);
            this.length += v.length;
        }
    }, {
        key: 'push',
        value: function push() {
            for (var _len = arguments.length, v = Array(_len), _key = 0; _key < _len; _key++) {
                v[_key] = arguments[_key];
            }

            this.pushArray(v);
        }
    }, {
        key: 'get',
        value: function get() {
            if (this.readPos < this.length) return this.array[this.readPos++];
            throw new Error('Read past end of buffer');
        }
    }, {
        key: 'pushUint8ArrayChecked',
        value: function pushUint8ArrayChecked(v, len) {
            if (v.length !== len) throw new Error('Binary data has incorrect size');
            this.pushArray(v);
        }
    }, {
        key: 'getUint8Array',
        value: function getUint8Array(len) {
            if (this.readPos + len > this.length) throw new Error('Read past end of buffer');
            var result = new Uint8Array(this.array.buffer, this.readPos, len);
            this.readPos += len;
            return result;
        }
    }, {
        key: 'pushUint16',
        value: function pushUint16(v) {
            this.push(v >> 0 & 0xff, v >> 8 & 0xff);
        }
    }, {
        key: 'getUint16',
        value: function getUint16() {
            var v = 0;
            v |= this.get() << 0;
            v |= this.get() << 8;
            return v;
        }
    }, {
        key: 'pushUint32',
        value: function pushUint32(v) {
            this.push(v >> 0 & 0xff, v >> 8 & 0xff, v >> 16 & 0xff, v >> 24 & 0xff);
        }
    }, {
        key: 'getUint32',
        value: function getUint32() {
            var v = 0;
            v |= this.get() << 0;
            v |= this.get() << 8;
            v |= this.get() << 16;
            v |= this.get() << 24;
            return v >>> 0;
        }
    }, {
        key: 'pushNumberAsUint64',
        value: function pushNumberAsUint64(v) {
            this.pushUint32(v >>> 0);
            this.pushUint32(Math.floor(v / 4294967296) >>> 0);
        }
    }, {
        key: 'getUint64AsNumber',
        value: function getUint64AsNumber() {
            var low = this.getUint32();
            var high = this.getUint32();
            return (high >>> 0) * 4294967296 + (low >>> 0);
        }
    }, {
        key: 'pushVaruint32',
        value: function pushVaruint32(v) {
            while (true) {
                if (v >>> 7) {
                    this.push(0x80 | v & 0x7f);
                    v = v >>> 7;
                } else {
                    this.push(v);
                    break;
                }
            }
        }
    }, {
        key: 'getVaruint32',
        value: function getVaruint32() {
            var v = 0;
            var bit = 0;
            while (true) {
                var b = this.get();
                v |= (b & 0x7f) << bit;
                bit += 7;
                if (!(b & 0x80)) break;
            }
            return v >>> 0;
        }
    }, {
        key: 'pushVarint32',
        value: function pushVarint32(v) {
            this.pushVaruint32(v << 1 ^ v >> 31);
        }
    }, {
        key: 'getVarint32',
        value: function getVarint32() {
            var v = this.getVaruint32();
            if (v & 1) return ~v >> 1 | 2147483648;else return v >>> 1;
        }
    }, {
        key: 'pushFloat32',
        value: function pushFloat32(v) {
            this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
        }
    }, {
        key: 'getFloat32',
        value: function getFloat32() {
            return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
        }
    }, {
        key: 'pushFloat64',
        value: function pushFloat64(v) {
            this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
        }
    }, {
        key: 'getFloat64',
        value: function getFloat64() {
            return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
        }
    }, {
        key: 'pushName',
        value: function pushName(s) {
            function charToSymbol(c) {
                if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) return c - 'a'.charCodeAt(0) + 6;
                if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) return c - '1'.charCodeAt(0) + 1;
                return 0;
            }
            var a = new Uint8Array(8);
            var bit = 63;
            for (var i = 0; i < s.length; ++i) {
                var c = charToSymbol(s.charCodeAt(i));
                if (bit < 5) c = c << 1;
                for (var j = 4; j >= 0; --j) {
                    if (bit >= 0) {
                        a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                        --bit;
                    }
                }
            }
            this.pushArray(a);
        }
    }, {
        key: 'getName',
        value: function getName() {
            var a = this.getUint8Array(8);
            var result = '';
            for (var bit = 63; bit >= 0;) {
                var c = 0;
                for (var i = 0; i < 5; ++i) {
                    if (bit >= 0) {
                        c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                        --bit;
                    }
                }
                if (c >= 6) result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);else if (c >= 1) result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);else result += '.';
            }
            if (result === '.............') return result;
            while (result.endsWith('.')) {
                result = result.substr(0, result.length - 1);
            }return result;
        }
    }, {
        key: 'pushBytes',
        value: function pushBytes(v) {
            this.pushVaruint32(v.length);
            this.pushArray(v);
        }
    }, {
        key: 'getBytes',
        value: function getBytes() {
            return this.getUint8Array(this.getVaruint32());
        }
    }, {
        key: 'pushString',
        value: function pushString(v) {
            this.pushBytes(this.textEncoder.encode(v));
        }
    }, {
        key: 'getString',
        value: function getString() {
            return this.textDecoder.decode(this.getBytes());
        }
    }, {
        key: 'pushSymbolCode',
        value: function pushSymbolCode(name) {
            var a = [];
            a.push.apply(a, _toConsumableArray(this.textEncoder.encode(name)));
            while (a.length < 8) {
                a.push(0);
            }this.pushArray(a.slice(0, 8));
        }
    }, {
        key: 'getSymbolCode',
        value: function getSymbolCode() {
            var a = this.getUint8Array(8);
            var len = void 0;
            for (len = 0; len < a.length; ++len) {
                if (!a[len]) break;
            }var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
            return name;
        }
    }, {
        key: 'pushSymbol',
        value: function pushSymbol(_ref2) {
            var name = _ref2.name,
                precision = _ref2.precision;

            var a = [precision & 0xff];
            a.push.apply(a, _toConsumableArray(this.textEncoder.encode(name)));
            while (a.length < 8) {
                a.push(0);
            }this.pushArray(a.slice(0, 8));
        }
    }, {
        key: 'getSymbol',
        value: function getSymbol() {
            var precision = this.get();
            var a = this.getUint8Array(7);
            var len = void 0;
            for (len = 0; len < a.length; ++len) {
                if (!a[len]) break;
            }var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
            return { name: name, precision: precision };
        }
    }, {
        key: 'pushAsset',
        value: function pushAsset(s) {
            s = s.trim();
            var pos = 0;
            var amount = '';
            var precision = 0;
            if (s[pos] === '-') {
                amount += '-';
                ++pos;
            }
            var foundDigit = false;
            while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
                foundDigit = true;
                amount += s[pos];
                ++pos;
            }
            if (!foundDigit) throw new Error('Asset must begin with a number');
            if (s[pos] === '.') {
                ++pos;
                while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
                    amount += s[pos];
                    ++precision;
                    ++pos;
                }
            }
            var name = s.substr(pos).trim();
            this.pushArray(numeric.signedDecimalToBinary(8, amount));
            this.pushSymbol({ name: name, precision: precision });
        }
    }, {
        key: 'getAsset',
        value: function getAsset() {
            var amount = this.getUint8Array(8);

            var _getSymbol = this.getSymbol(),
                name = _getSymbol.name,
                precision = _getSymbol.precision;

            var s = numeric.signedBinaryToDecimal(amount, precision + 1);
            if (precision) s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);
            return s + ' ' + name;
        }
    }, {
        key: 'pushPublicKey',
        value: function pushPublicKey(s) {
            var key = numeric.stringToPublicKey(s);
            this.push(key.type);
            this.pushArray(key.data);
        }
    }, {
        key: 'getPublicKey',
        value: function getPublicKey() {
            var type = this.get();
            var data = this.getUint8Array(numeric.publicKeyDataSize);
            return numeric.publicKeyToString({ type: type, data: data });
        }
    }, {
        key: 'pushPrivateKey',
        value: function pushPrivateKey(s) {
            var key = numeric.stringToPrivateKey(s);
            this.push(key.type);
            this.pushArray(key.data);
        }
    }, {
        key: 'getPrivateKey',
        value: function getPrivateKey() {
            var type = this.get();
            var data = this.getUint8Array(numeric.privateKeyDataSize);
            return numeric.privateKeyToString({ type: type, data: data });
        }
    }, {
        key: 'pushSignature',
        value: function pushSignature(s) {
            var key = numeric.stringToSignature(s);
            this.push(key.type);
            this.pushArray(key.data);
        }
    }, {
        key: 'getSignature',
        value: function getSignature() {
            var type = this.get();
            var data = this.getUint8Array(numeric.signatureDataSize);
            return numeric.signatureToString({ type: type, data: data });
        }
    }]);

    return SerialBuffer;
}(); // SerialBuffer


function dateToTimePoint(date) {
    return Math.round(Date.parse(date + 'Z') * 1000);
}
function timePointToDate(us) {
    var s = new Date(us / 1000).toISOString();
    return s.substr(0, s.length - 1);
}
function dateToTimePointSec(date) {
    return Math.round(Date.parse(date + 'Z') / 1000);
}
function timePointSecToDate(sec) {
    var s = new Date(sec * 1000).toISOString();
    return s.substr(0, s.length - 1);
}
function dateToBlockTimestamp(date) {
    return Math.round((Date.parse(date + 'Z') - 946684800000) / 500);
}
function blockTimestampToDate(slot) {
    var s = new Date(slot * 500 + 946684800000).toISOString();
    return s.substr(0, s.length - 1);
}
function stringToSymbol(s) {
    var m = s.match(/^([0-9]+),([A-Z]+)$/);
    if (!m) throw new Error('Invalid symbol');
    return { name: m[2], precision: +m[1] };
}
function symbolToString(_ref3) {
    var name = _ref3.name,
        precision = _ref3.precision;

    return precision + ',' + name;
}
function arrayToHex(data) {
    var result = '';
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var x = _step.value;

            result += ('00' + x.toString(16)).slice(-2);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return result.toUpperCase();
}
function hexToUint8Array(hex) {
    var l = hex.length / 2;
    var result = new Uint8Array(l);
    for (var i = 0; i < l; ++i) {
        result[i] = parseInt(hex.substr(i * 2, 2), 16);
    }return result;
}
function serializeUnknown(buffer, data) {
    throw new Error("Don't know how to serialize " + this.name);
}
function deserializeUnknown(buffer) {
    throw new Error("Don't know how to deserialize " + this.name);
}
function serializeStruct(buffer, data) {
    if (this.base) this.base.serialize(buffer, data);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = this.fields[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var field = _step2.value;

            if (!(field.name in data)) throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type.name + ')');
            field.type.serialize(buffer, data[field.name]);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }
}
function deserializeStruct(buffer) {
    var result = void 0;
    if (this.base) result = this.base.deserialize(buffer);else result = {};
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = this.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var field = _step3.value;

            result[field.name] = field.type.deserialize(buffer);
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return result;
}
function serializeArray(buffer, data) {
    buffer.pushVaruint32(data.length);
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var item = _step4.value;

            this.arrayOf.serialize(buffer, item);
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }
}
function deserializeArray(buffer) {
    var len = buffer.getVaruint32();
    var result = [];
    for (var i = 0; i < len; ++i) {
        result.push(this.arrayOf.deserialize(buffer));
    }return result;
}
function serializeOptional(buffer, data) {
    if (data === null || data === undefined) {
        buffer.push(0);
    } else {
        buffer.push(1);
        this.optionalOf.serialize(buffer, data);
    }
}
function deserializeOptional(buffer) {
    if (buffer.get()) return this.optionalOf.deserialize(buffer);else return null;
}
function createType(attrs) {
    return Object.assign({ name: '<missing name>', aliasOfName: '', arrayOf: null, optionalOf: null, baseName: '', base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
}
function createInitialTypes() {
    var result = new Map(Object.entries({
        bool: createType({
            name: 'bool',
            serialize: function serialize(buffer, data) {
                buffer.push(data ? 1 : 0);
            },
            deserialize: function deserialize(buffer) {
                return !!buffer.get();
            }
        }),
        uint8: createType({
            name: 'uint8',
            serialize: function serialize(buffer, data) {
                buffer.push(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.get();
            }
        }),
        int8: createType({
            name: 'int8',
            serialize: function serialize(buffer, data) {
                buffer.push(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.get() << 24 >> 24;
            }
        }),
        uint16: createType({
            name: 'uint16',
            serialize: function serialize(buffer, data) {
                buffer.pushUint16(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getUint16();
            }
        }),
        int16: createType({
            name: 'int16',
            serialize: function serialize(buffer, data) {
                buffer.pushUint16(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getUint16() << 16 >> 16;
            }
        }),
        uint32: createType({
            name: 'uint32',
            serialize: function serialize(buffer, data) {
                buffer.pushUint32(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getUint32();
            }
        }),
        uint64: createType({
            name: 'uint64',
            serialize: function serialize(buffer, data) {
                buffer.pushArray(numeric.decimalToBinary(8, '' + data));
            },
            deserialize: function deserialize(buffer) {
                return numeric.binaryToDecimal(buffer.getUint8Array(8));
            }
        }),
        int64: createType({
            name: 'int64',
            serialize: function serialize(buffer, data) {
                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));
            },
            deserialize: function deserialize(buffer) {
                return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
            }
        }),
        int32: createType({
            name: 'int32',
            serialize: function serialize(buffer, data) {
                buffer.pushUint32(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getUint32() | 0;
            }
        }),
        varuint32: createType({
            name: 'varuint32',
            serialize: function serialize(buffer, data) {
                buffer.pushVaruint32(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getVaruint32();
            }
        }),
        varint32: createType({
            name: 'varint32',
            serialize: function serialize(buffer, data) {
                buffer.pushVarint32(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getVarint32();
            }
        }),
        uint128: createType({
            name: 'uint128',
            serialize: function serialize(buffer, data) {
                buffer.pushArray(numeric.decimalToBinary(16, data));
            },
            deserialize: function deserialize(buffer) {
                return numeric.binaryToDecimal(buffer.getUint8Array(16));
            }
        }),
        int128: createType({
            name: 'int128',
            serialize: function serialize(buffer, data) {
                buffer.pushArray(numeric.signedDecimalToBinary(16, data));
            },
            deserialize: function deserialize(buffer) {
                return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
            }
        }),
        float32: createType({
            name: 'float32',
            serialize: function serialize(buffer, data) {
                buffer.pushFloat32(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getFloat32();
            }
        }),
        float64: createType({
            name: 'float64',
            serialize: function serialize(buffer, data) {
                buffer.pushFloat64(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getFloat64();
            }
        }),
        float128: createType({
            name: 'float128',
            serialize: function serialize(buffer, data) {
                buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);
            },
            deserialize: function deserialize(buffer) {
                return arrayToHex(buffer.getUint8Array(16));
            }
        }),
        bytes: createType({
            name: 'bytes',
            serialize: function serialize(buffer, data) {
                buffer.pushBytes(hexToUint8Array(data));
            },
            deserialize: function deserialize(buffer) {
                return arrayToHex(buffer.getBytes());
            }
        }),
        string: createType({
            name: 'string',
            serialize: function serialize(buffer, data) {
                buffer.pushString(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getString();
            }
        }),
        name: createType({
            name: 'name',
            serialize: function serialize(buffer, data) {
                buffer.pushName(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getName();
            }
        }),
        time_point: createType({
            name: 'time_point',
            serialize: function serialize(buffer, data) {
                buffer.pushNumberAsUint64(dateToTimePoint(data));
            },
            deserialize: function deserialize(buffer) {
                return timePointToDate(buffer.getUint64AsNumber());
            }
        }),
        time_point_sec: createType({
            name: 'time_point_sec',
            serialize: function serialize(buffer, data) {
                buffer.pushUint32(dateToTimePointSec(data));
            },
            deserialize: function deserialize(buffer) {
                return timePointSecToDate(buffer.getUint32());
            }
        }),
        block_timestamp_type: createType({
            name: 'block_timestamp_type',
            serialize: function serialize(buffer, data) {
                buffer.pushUint32(dateToBlockTimestamp(data));
            },
            deserialize: function deserialize(buffer) {
                return blockTimestampToDate(buffer.getUint32());
            }
        }),
        symbol_code: createType({
            name: 'symbol_code',
            serialize: function serialize(buffer, data) {
                buffer.pushSymbolCode(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getSymbolCode();
            }
        }),
        symbol: createType({
            name: 'symbol',
            serialize: function serialize(buffer, data) {
                buffer.pushSymbol(stringToSymbol(data));
            },
            deserialize: function deserialize(buffer) {
                return symbolToString(buffer.getSymbol());
            }
        }),
        asset: createType({
            name: 'asset',
            serialize: function serialize(buffer, data) {
                buffer.pushAsset(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getAsset();
            }
        }),
        checksum160: createType({
            name: 'checksum160',
            serialize: function serialize(buffer, data) {
                buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);
            },
            deserialize: function deserialize(buffer) {
                return arrayToHex(buffer.getUint8Array(20));
            }
        }),
        checksum256: createType({
            name: 'checksum256',
            serialize: function serialize(buffer, data) {
                buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);
            },
            deserialize: function deserialize(buffer) {
                return arrayToHex(buffer.getUint8Array(32));
            }
        }),
        checksum512: createType({
            name: 'checksum512',
            serialize: function serialize(buffer, data) {
                buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);
            },
            deserialize: function deserialize(buffer) {
                return arrayToHex(buffer.getUint8Array(64));
            }
        }),
        public_key: createType({
            name: 'public_key',
            serialize: function serialize(buffer, data) {
                buffer.pushPublicKey(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getPublicKey();
            }
        }),
        private_key: createType({
            name: 'private_key',
            serialize: function serialize(buffer, data) {
                buffer.pushPrivateKey(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getPrivateKey();
            }
        }),
        signature: createType({
            name: 'signature',
            serialize: function serialize(buffer, data) {
                buffer.pushSignature(data);
            },
            deserialize: function deserialize(buffer) {
                return buffer.getSignature();
            }
        })
    }));
    result.set('extended_asset', createType({
        name: 'extended_asset',
        baseName: '',
        fields: [{ name: 'quantity', typeName: 'asset', type: result.get('asset') }, { name: 'contract', typeName: 'name', type: result.get('name') }],
        serialize: serializeStruct,
        deserialize: deserializeStruct
    }));
    return result;
} // createInitialTypes()
function getType(types, name) {
    var type = types.get(name);
    if (type && type.aliasOfName) return getType(types, type.aliasOfName);
    if (type) return type;
    if (name.endsWith('[]')) {
        return createType({
            name: name,
            arrayOf: getType(types, name.substr(0, name.length - 2)),
            serialize: serializeArray,
            deserialize: deserializeArray
        });
    }
    if (name.endsWith('?')) {
        return createType({
            name: name,
            optionalOf: getType(types, name.substr(0, name.length - 1)),
            serialize: serializeOptional,
            deserialize: deserializeOptional
        });
    }
    throw new Error('Unknown type: ' + name);
}
function getTypesFromAbi(initialTypes, abi) {
    var types = new Map(initialTypes);
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        for (var _iterator5 = abi.types[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _ref4 = _step5.value;
            var new_type_name = _ref4.new_type_name,
                type = _ref4.type;

            types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
        }
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }

    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
        for (var _iterator6 = abi.structs[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _ref5 = _step6.value;
            var name = _ref5.name,
                base = _ref5.base,
                fields = _ref5.fields;

            types.set(name, createType({
                name: name,
                baseName: base,
                fields: fields.map(function (_ref8) {
                    var name = _ref8.name,
                        type = _ref8.type;
                    return { name: name, typeName: type, type: null };
                }),
                serialize: serializeStruct,
                deserialize: deserializeStruct
            }));
        }
    } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
            }
        } finally {
            if (_didIteratorError6) {
                throw _iteratorError6;
            }
        }
    }

    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
        for (var _iterator7 = types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _ref6 = _step7.value;

            var _ref7 = _slicedToArray(_ref6, 2);

            var _name = _ref7[0];
            var _type = _ref7[1];

            if (_type.baseName) _type.base = getType(types, _type.baseName);
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = _type.fields[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var field = _step8.value;

                    field.type = getType(types, field.typeName);
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
            }
        } finally {
            if (_didIteratorError7) {
                throw _iteratorError7;
            }
        }
    }

    return types;
} // getTypesFromAbi
function transactionHeader(refBlock, expireSeconds) {
    return {
        expiration: timePointSecToDate(dateToTimePointSec(refBlock.timestamp) + expireSeconds),
        ref_block_num: refBlock.block_num,
        ref_block_prefix: refBlock.ref_block_prefix
    };
}
;
function serializeActionData(contract, account, name, data) {
    var action = contract.actions.get(name);
    if (!action) throw new Error('Unknown action ' + name + ' in contract ' + account);
    var buffer = new SerialBuffer();
    action.serialize(buffer, data);
    return arrayToHex(buffer.asUint8Array());
}
function serializeAction(contract, account, name, authorization, data) {
    return {
        account: account,
        name: name,
        authorization: authorization,
        data: serializeActionData(contract, account, name, data)
    };
}
//# sourceMappingURL=eosjs2-serialize.js.map