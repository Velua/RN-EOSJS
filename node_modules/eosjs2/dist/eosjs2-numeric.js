// copyright defined in eosjs2/LICENSE.txt
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNegative = isNegative;
exports.negate = negate;
exports.decimalToBinary = decimalToBinary;
exports.signedDecimalToBinary = signedDecimalToBinary;
exports.binaryToDecimal = binaryToDecimal;
exports.signedBinaryToDecimal = signedBinaryToDecimal;
exports.base58ToBinary = base58ToBinary;
exports.binaryToBase58 = binaryToBase58;
exports.stringToPublicKey = stringToPublicKey;
exports.publicKeyToString = publicKeyToString;
exports.stringToPrivateKey = stringToPrivateKey;
exports.privateKeyToString = privateKeyToString;
exports.stringToSignature = stringToSignature;
exports.signatureToString = signatureToString;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var ripemd160 = require('./ripemd').RIPEMD160.hash;
var base58_chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function create_base58_map() {
    var base58_map = Array(256).fill(-1);
    for (var i = 0; i < base58_chars.length; ++i) {
        base58_map[base58_chars.charCodeAt(i)] = i;
    }return base58_map;
}
var base58_map = create_base58_map();
function isNegative(bin) {
    return (bin[bin.length - 1] & 0x80) !== 0;
}
function negate(bin) {
    var carry = 1;
    for (var i = 0; i < bin.length; ++i) {
        var x = (~bin[i] & 0xff) + carry;
        bin[i] = x;
        carry = x >> 8;
    }
}
function decimalToBinary(size, s) {
    var result = new Uint8Array(size);
    for (var i = 0; i < s.length; ++i) {
        var srcDigit = s.charCodeAt(i);
        if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) throw new Error("invalid number");
        var carry = srcDigit - '0'.charCodeAt(0);
        for (var j = 0; j < size; ++j) {
            var x = result[j] * 10 + carry;
            result[j] = x;
            carry = x >> 8;
        }
        if (carry) throw new Error("number is out of range");
    }
    return result;
}
function signedDecimalToBinary(size, s) {
    var negative = s[0] === '-';
    if (negative) s = s.substr(1);
    var result = decimalToBinary(size, s);
    if (negative) negate(result);
    return result;
}
function binaryToDecimal(bin) {
    var minDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var result = Array(minDigits).fill('0'.charCodeAt(0));
    for (var i = bin.length - 1; i >= 0; --i) {
        var carry = bin[i];
        for (var j = 0; j < result.length; ++j) {
            var x = (result[j] - '0'.charCodeAt(0) << 8) + carry;
            result[j] = '0'.charCodeAt(0) + x % 10;
            carry = x / 10 | 0;
        }
        while (carry) {
            result.push('0'.charCodeAt(0) + carry % 10);
            carry = carry / 10 | 0;
        }
    }
    result.reverse();
    return String.fromCharCode.apply(String, _toConsumableArray(result));
}
function signedBinaryToDecimal(bin) {
    var minDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    if (isNegative(bin)) {
        var x = bin.slice();
        negate(x);
        return '-' + binaryToDecimal(x, minDigits);
    }
    return binaryToDecimal(bin, minDigits);
}
function base58ToBinary(size, s) {
    var result = new Uint8Array(size);
    for (var i = 0; i < s.length; ++i) {
        var carry = base58_map[s.charCodeAt(i)];
        if (carry < 0) throw new Error("invalid base-58 value");
        for (var j = 0; j < size; ++j) {
            var x = result[j] * 58 + carry;
            result[j] = x;
            carry = x >> 8;
        }
        if (carry) throw new Error("base-58 value is out of range");
    }
    result.reverse();
    return result;
}
function binaryToBase58(bin) {
    var minDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var result = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = bin[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var byte = _step.value;

            var carry = byte;
            for (var j = 0; j < result.length; ++j) {
                var x = (base58_map[result[j]] << 8) + carry;
                result[j] = base58_chars.charCodeAt(x % 58);
                carry = x / 58 | 0;
            }
            while (carry) {
                result.push(base58_chars.charCodeAt(carry % 58));
                carry = carry / 58 | 0;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = bin[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _byte = _step2.value;

            if (_byte) break;else result.push('1'.charCodeAt(0));
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    result.reverse();
    return String.fromCharCode.apply(String, result);
}
;
var publicKeyDataSize = exports.publicKeyDataSize = 33;
var privateKeyDataSize = exports.privateKeyDataSize = 32;
var signatureDataSize = exports.signatureDataSize = 65;
;
function digestSuffixRipemd160(data, suffix) {
    var d = new Uint8Array(data.length + suffix.length);
    for (var i = 0; i < data.length; ++i) {
        d[i] = data[i];
    }for (var _i = 0; _i < suffix.length; ++_i) {
        d[data.length + _i] = suffix.charCodeAt(_i);
    }return ripemd160(d);
}
function stringToKey(s, type, size, suffix) {
    var whole = base58ToBinary(size + 4, s);
    var result = { type: type, data: new Uint8Array(whole.buffer, 0, size) };
    var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
    if (digest[0] !== whole[size + 0] || digest[1] !== whole[size + 1] || digest[2] !== whole[size + 2] || digest[3] !== whole[size + 3]) throw new Error("checksum doesn't match");
    return result;
}
function keyToString(key, suffix, prefix) {
    var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
    var whole = new Uint8Array(key.data.length + 4);
    for (var i = 0; i < key.data.length; ++i) {
        whole[i] = key.data[i];
    }for (var _i2 = 0; _i2 < 4; ++_i2) {
        whole[_i2 + key.data.length] = digest[_i2];
    }return prefix + binaryToBase58(whole);
}
function stringToPublicKey(s) {
    if (s.substr(0, 3) == "EOS") {
        var whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));
        var key = { type: 0 /* k1 */, data: new Uint8Array(publicKeyDataSize) };
        for (var i = 0; i < publicKeyDataSize; ++i) {
            key.data[i] = whole[i];
        }var digest = new Uint8Array(ripemd160(key.data));
        if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) throw new Error("checksum doesn't match");
        return key;
    } else if (s.substr(0, 7) == "PUB_R1_") {
        return stringToKey(s.substr(7), 1 /* r1 */, publicKeyDataSize, "R1");
    } else {
        throw new Error("unrecognized public key format");
    }
}
function publicKeyToString(key) {
    if (key.type == 0 /* k1 */ && key.data.length == publicKeyDataSize) {
        var digest = new Uint8Array(ripemd160(key.data));
        var whole = new Uint8Array(publicKeyDataSize + 4);
        for (var i = 0; i < publicKeyDataSize; ++i) {
            whole[i] = key.data[i];
        }for (var _i3 = 0; _i3 < 4; ++_i3) {
            whole[_i3 + publicKeyDataSize] = digest[_i3];
        }return "EOS" + binaryToBase58(whole);
    } else if (key.type == 1 /* r1 */ && key.data.length == publicKeyDataSize) {
        return keyToString(key, "R1", "PUB_R1_");
    } else {
        throw new Error("unrecognized public key format");
    }
}
function stringToPrivateKey(s) {
    if (s.substr(0, 7) == "PVT_R1_") return stringToKey(s.substr(7), 1 /* r1 */, privateKeyDataSize, "R1");else throw new Error("unrecognized private key format");
}
function privateKeyToString(signature) {
    if (signature.type == 1 /* r1 */) return keyToString(signature, "R1", "PVT_R1_");else throw new Error("unrecognized private key format");
}
function stringToSignature(s) {
    if (s.substr(0, 7) == "SIG_K1_") return stringToKey(s.substr(7), 0 /* k1 */, signatureDataSize, "K1");else if (s.substr(0, 7) == "SIG_R1_") return stringToKey(s.substr(7), 1 /* r1 */, signatureDataSize, "R1");else throw new Error("unrecognized signature format");
}
function signatureToString(signature) {
    if (signature.type == 0 /* k1 */) return keyToString(signature, "K1", "SIG_K1_");else if (signature.type == 1 /* r1 */) return keyToString(signature, "R1", "SIG_R1_");else throw new Error("unrecognized signature format");
}
//# sourceMappingURL=eosjs2-numeric.js.map